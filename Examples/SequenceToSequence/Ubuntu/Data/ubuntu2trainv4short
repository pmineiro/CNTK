#! /usr/bin/env perl

use warnings;
use strict;

use Text::CSV;
use Data::Dumper;

sub save_hash ($$)
{
  my ($filename, $hash) = @_;
  my $fh = new IO::File $filename, "w" or die "$filename: $!";
  $fh->binmode (":utf8");

  while (my ($k, $v) = each %$hash)
    {
      my ($n, $c) = @$v;
      print $fh "$k\t$n\t$c\n";
    }
}

sub load_hash ($$)
{
  my ($filename, $hash) = @_;
  my $fh = new IO::File $filename, "r" or die "$filename: $!";

  while (defined ($_ = <$fh>))
    {
      chomp;
      my ($k, $v, $c) = split /\t/, $_, 3;

      $hash->{$k} = [ $v, $c ];
    }
}

my $oov = 0;

sub encode ($$)
{
  my ($v, $dict) = @_;

  $dict->{$v} ||= do { ++$oov; [ (scalar keys %$dict), 0 ] };
  ++$dict->{$v}->[1];

  return $dict->{$v}->[0];
}

sub tokenize ($)
{
  my ($s) = @_;

  return map { substr ($_, 0, 7) } split /\s+/, $s;
}

sub preprocess ($)
{
  my ($v) = @_;

  $v =~ s/([[:punct:]]+)\s/ $1 /g;
  $v =~ s/\s([[:punct:]]+)/ $1 /g;
  $v = lc ($v);

  return $v;
}

#----------------------------------------------------------------

my %vocab;

my $skip = 0;
sub printexample ($@)
{
  my ($sid, $context, @queries) = @_;

  local $\="\n";

  my @fullcontext = tokenize preprocess $context;
  my @context = @fullcontext > 40 ? splice @fullcontext, -40 : @fullcontext;

  my @tokenized = map { [ split /\s+/, tokenize preprocess ($_) ] } @queries;

  my $ml = join " ", "|MultiLabel", "1", map { 0 } (1 .. $#queries);

  do { ++$skip; return undef; } unless @context && (@tokenized == scalar grep { @$_} @tokenized);

  while (@context || grep { @$_ } @tokenized)
    {
      my $ct = @context ? "|Context @{[encode (shift @context, \%vocab)]}:1" : "";
      my $num = 1;
      my @qt = map { @{$tokenized[$_]} ? "|Query$_ @{[encode (shift @{$tokenized[$_]}, \%vocab)]}:1" : "" } (0 .. $#tokenized);

      print join " ", $sid, $ml, $ct, @qt;

      $ml = "";
    }
}

#----------------------------------------------------------------

my $mode = shift @ARGV or die;
$mode eq "megatrain" || $mode eq "test" || $mode eq "valid" or die "bad mode $mode";
my $vocabfile = "shortvocab4";

if ($mode eq "test" || $mode eq "valid")
  {
    load_hash ($vocabfile, \%vocab);
  }

my $csv = Text::CSV->new ({ binary => 1 }) or die Text::CSV->error_diag ();

# eat header
<>;

my $sid = 1;
my $maxsid = $mode eq "megatrain" ? 100000 : 10000;
my @positives;
my @negatives;

while (my $row = $csv->getline (*ARGV))
  {
    my @fields = @$row;

    do { warn scalar @fields; warn Dumper (\@fields); die "wtf" } unless @fields == 11;

    printexample ($sid, @fields);

    last if ++$sid > $maxsid;
  }

save_hash ($vocabfile, \%vocab);

warn join "\t", $oov, $skip;
